# Google ADK Runner - End-to-End Explanation

The Runner is the core execution engine in Google ADK that manages the lifecycle of agent interactions. It orchestrates the execution of agents within sessions, handling message processing, event generation, and interaction with various services.

## Core Components

### 1. Runner Class
The main entry point for executing agents. It manages:
- Agent execution within sessions
- Interaction with service providers (session, artifact, memory, credential)
- Plugin management
- Event generation and processing

### 2. Services
The Runner depends on several service providers:
- **SessionService**: Manages conversation sessions and their state
- **ArtifactService**: Handles file storage and retrieval
- **MemoryService**: Provides long-term memory capabilities
- **CredentialService**: Manages authentication credentials

### 3. Key Data Structures
- **Session**: Represents a conversation with state and event history
- **Event**: Represents individual interactions (messages, function calls, etc.)
- **InvocationContext**: Contains execution context for a single agent invocation

## End-to-End Flow

### 1. Initialization
When a Runner is created, it requires:
```python
runner = Runner(
    app_name="my_app",
    agent=my_agent,  # The root agent to execute
    session_service=MySessionService(),  # Required
    artifact_service=MyArtifactService(),  # Optional
    memory_service=MyMemoryService(),  # Optional
    credential_service=MyCredentialService(),  # Optional
    plugins=[MyPlugin()]  # Optional
)
```

### 2. Execution Entry Points
The Runner provides two main execution methods:

#### run_async() (Primary Method)
```python
async def run_async(
    self,
    *,
    user_id: str,
    session_id: str,
    new_message: types.Content,
    state_delta: Optional[dict[str, Any]] = None,
    run_config: RunConfig = RunConfig(),
) -> AsyncGenerator[Event, None]:
```

#### run() (Synchronous Wrapper)
```python
def run(
    self,
    *,
    user_id: str,
    session_id: str,
    new_message: types.Content,
    run_config: RunConfig = RunConfig(),
) -> Generator[Event, None, None]:
```

### 3. Execution Flow

#### Step 1: Session Retrieval
The Runner first retrieves the existing session:
```python
session = await self.session_service.get_session(
    app_name=self.app_name, 
    user_id=user_id, 
    session_id=session_id
)
```

#### Step 2: Invocation Context Creation
Creates an `InvocationContext` that contains:
- References to all services
- Plugin manager
- Session data
- New user message
- Execution configuration

#### Step 3: Agent Selection
The Runner determines which agent should handle the interaction:
- If the last event was a function response, route to the agent that made the call
- Otherwise, find the appropriate agent in the hierarchy based on conversation flow

#### Step 4: Message Processing
The new user message is processed and appended to the session:
- Artifacts (files) are extracted and stored via ArtifactService if configured
- The message is added to the session via SessionService

#### Step 5: Agent Execution
The selected agent is executed with plugin callbacks:
1. **Before Run**: Plugins can modify execution or provide early responses
2. **Execution**: The agent processes the message and generates events
3. **On Event**: Plugins can modify individual events as they're generated
4. **After Run**: Plugins can perform cleanup or final modifications

#### Step 6: Event Handling
Events generated by the agent are:
- Stored in the session via SessionService
- Yielded to the caller for real-time processing
- Processed by plugins for additional functionality

### 4. Live Mode (Experimental)
The Runner also supports a live mode for real-time interactions:
```python
async def run_live(
    self,
    *,
    user_id: Optional[str] = None,
    session_id: Optional[str] = None,
    live_request_queue: LiveRequestQueue,
    run_config: RunConfig = RunConfig(),
    session: Optional[Session] = None,
) -> AsyncGenerator[Event, None]:
```

This mode supports streaming interactions and real-time agent transfers.

### 5. Cleanup
The Runner provides a `close()` method to properly clean up resources, particularly for toolsets that may have background tasks.

## Key Features

### Plugin System
The Runner integrates with a plugin system that allows:
- Pre-execution modifications
- Event interception and modification
- Post-execution cleanup
- Custom behavior injection

### Service Integration
All four service types are seamlessly integrated:
- **SessionService**: Core conversation persistence
- **ArtifactService**: File handling and storage
- **MemoryService**: Long-term memory and context
- **CredentialService**: Secure credential management

### Error Handling
The Runner includes robust error handling:
- Session validation and retrieval
- Proper resource cleanup
- Exception propagation with context

### Observability
Built-in telemetry support through OpenTelemetry for tracing and monitoring.

## Usage Patterns

### Simple Usage
```python
# Create runner with in-memory services for testing
runner = InMemoryRunner(agent=my_agent)

# Execute with a user message
for event in runner.run(
    user_id="user123",
    session_id="session456",
    new_message=types.Content(parts=[types.Part(text="Hello, AI!")])
):
    print(f"Event: {event.content}")
```

### Production Usage
```python
# Create runner with production services
runner = Runner(
    app_name="production_app",
    agent=my_agent,
    session_service=DatabaseSessionService("postgresql://..."),
    artifact_service=S3ArtifactService("s3://..."),
    memory_service=DatabaseMemoryService("postgresql://..."),
    credential_service=VaultCredentialService()
)

# Execute asynchronously for better performance
async for event in runner.run_async(
    user_id="user123",
    session_id="session456",
    new_message=types.Content(parts=[types.Part(text="Process this document")]),
    run_config=RunConfig(max_llm_calls=10)
):
    # Handle events in real-time
    await process_event(event)
```

## Architecture Benefits

1. **Modularity**: Services can be swapped without changing agent logic
2. **Extensibility**: Plugins provide hook points for custom functionality
3. **Observability**: Built-in tracing and metrics support
4. **Flexibility**: Supports both synchronous and asynchronous execution
5. **Robustness**: Proper error handling and resource management
6. **Scalability**: Designed for both development and production use

The Runner serves as the central orchestrator that brings together all components of the ADK ecosystem, providing a powerful yet flexible platform for building AI agent applications.